use std::str::FromStr;
use crate::helpers::remove_first_last;
use crate::lexer::Token;
use crate::parser::Line;
use crate::error::ParseError;

grammar<'input>(input: &'input str);

pub Lines: Vec<Line<'input>> = <Line*>;

pub Line: Line<'input> = {
    Define => <>,
    BlockBegin => <>,
    BlockEnd => <>,
    Assignment => <>,
    "EOL" => Line::EndOfLine,
    <comment:"Comment"> => Line::Comment(comment),
}

BlockBegin: Line<'input> = {
    "BlockKeyword" "=" <name:"ValueString"> <comment:"Comment"?> <eol:"EOL"?> "{" =>? match eol {
        None => Err(lalrpop_util::ParseError::User {
            error: ParseError::new_missing_new_line()
        }),
        Some(_) => Ok(Line::BlockBegin(name, comment)),
    },
}

BlockEnd: Line<'input> = {
    "}" <comment:"Comment"?> "EOL" => Line::BlockEnd(comment),
}

Define: Line<'input> = {
    <d:"Define"> <name:"Key"> "=" <value:Value> <comment:"Comment"?> "EOL" => Line::Define(name, value, comment),
}

// TODO: I'm not sure we should be parsing variables like this here...
// It might be easier to treat everything as a string, and handle variables
// later. Technically, variables could be anything. E.G.
// export TEST="TEST=1234"
Assignment: Line<'input> = {
    <key:"Key"> "=" <value:Value> <comment:"Comment"?> "EOL" => Line::Assignment(key,value, comment),
    <key:"Variable"> "=" <value:Value> <comment:"Comment"?> "EOL" => Line::Assignment(key,value, comment),
}

// TODO: The original MOOS parser treated everything after the equal sign as
// the value. It also allowed for anything before the equal to be the key..
// Should we match the original implementation or write something that
// applies stricter rules. E.G. keys must be an identifier: [a-zA-Z0-9_-.]+
Value: &'input str = {
    <value:"ValueString"> => value,
    <value:"Quote"> =>value,
}

extern {  
    type Location = usize;
    type Error = ParseError;
    
    enum Token<'input> {
        "(" => Token::ParenOpen, 
        ")" => Token::ParenClose, 
        "=" => Token::AssignOp,
        "Comment" => Token::Comment(<&'input str>),
        "Quote" => Token::Quote(<&'input str>),
        "Define" => Token::DefineKeyword,
        "BlockKeyword" => Token::BlockKeyword(<&'input str>),
        "Key" => Token::Key(<&'input str>),
        "ValueString" => Token::ValueString(<&'input str>),
        "EOL" => Token::EOL,
        "Variable" => Token::Variable(<&'input str>),
        "{" => Token::CurlyOpen,
        "}" => Token::CurlyClose,
    }
}
